---
title: Dotfilesを作ってみる
tags: [個人開発]
createDate: 2023-02-20
updateDate: 2023-02-20
slug: dotfiles
---


## 参考

https://qiita.com/yutkat/items/c6c7584d9795799ee164  
https://dev.classmethod.jp/articles/joined-mac-dotfiles-customize/  

## はじめに

今週M2 Pro Mac mini(2023)を購入しました!

2023モデルのM2チップ搭載Mac miniは最小構成で84800円と前モデルより安くなっていてライトな使い方にもピッタリのコスパになっています。  
そしてM2 Proチップ搭載のMac miniは184800円からですがメモリを32GBまで増設可能で個人使用であれば十分なスペックを選択できるようになりました。  
M2とM2 Proのモデルにはほかにもポートの違い等がありますが詳細は割愛します。  

私用のMacとしては2019モデルのMacbook Proを最小構成で購入して以来のPCで二台目となります。  
また、Apple SiliconのMacを購入するのが初めてなので思い切ってメモリを32GBにカスタマイズして購入しました！

今回は新しいMacの設定をしながら、dotfilesと呼ばれる設定ファイル管理用リポジトリを作成しました。  
チーム内で雑談しているときに話題に上げたのですが思ったよりみんな知らない文化だったので布教の意味も込めて記事にしてみます。  
自身のdotfilesはまだまだ細部までこだわれてないので今回は文化の紹介という感じでライトな記事にしたいと思います。  

## dotfilesとは
dotfilesとは、普段自身で使っているソフトウェアの設定ファイルをまとめて管理するリポジトリです。  
慣例的に`.`(ドット)から始めるファイルになっているため`dotfiles`と呼ばれています。  

## dotfilesの目的

- どんな環境で作業することになっても自分の環境をさくっと用意できる
- docker等で環境を立ち上げた際にも簡単に環境を用意できる

そして何よりすぐ新しいパソコンを買っちゃったとしてもすぐにセットアップができる!

## dotfilesのはじめかた

まずは簡単な設定ファイルを置くところから始めます。  
GitHubにdotfilesという名前でリポジトリを作成します。  
このとき、GitHub Actions等でのCIを考えていたりする場合はpublicリポジトリで作成しておくといいと思います。  
当然ながら機密性の高い情報やキャッシュ等のファイルはgitに追加しないようにしておきましょう!  

dotfilesはホームディレクトリ直下にcloneするようにしておくと使い勝手がいいかと思います。

今回はまずシェルの設定から追加してみます。  
自身のシェルの設定をdotfiles配下にコピーします。  
あとでシンボリックリンクを貼るので移動してもいいと思います。  
```
mv ~./bashrc ~/dotfiles/.zshrc
```

ホームディレクトリに対してシンボリックリンクを作成します。  
```
ln -s ~/dotfiles/.zshrc ~zshrc
```

これでシェルの設定がdotfiles配下の設定ファイルを参照するようになりました。


## dotfilesを工夫してみる

### dotfilesのホワイトリスト化

エディタやシェルにプラグインを入れたりすると勝手にファイルが作られることがあるため、その更新が見えないように.gitignoreをホワイトリストにします。
```
# 全ての階層を無視
/*
/.**

# ホワイトリスト
!/.zshrc
!/README.md
!/LICENSE
!.gitignore

# ほかにも追加したいものを追加
```

### macOSの場合はHomebrewのインストールファイルも作成する

今の環境からインストールリストファイルを作成するには下記のコマンドを実行します。
```
brew bundle dump
```

新しい環境で下記コマンドを実行すると先ほど作成した`.Brewfile`が読み込まれ、一括インストールされます。

```
brew bundle --global
```

私の環境では最低限下記のような`Brewfile`を作成しました。  

```
tap "homebrew/bundle"
tap "homebrew/cask"
tap "homebrew/core"
brew "anyenv"
brew "php"
brew "composer"
brew "jq"
brew "tree"

cask "authy"
cask "docker"
cask "iterm2"
cask "postman"
cask "sequel-ace"
cask "visual-studio-code"
cask "google-chrome"
cask "kindle"
cask "slack"
```

よく使う構文をいくつか紹介しておきます。  

### `tap`

Homebrewに正式に登録されてはいないライブラリをインストールする際に`tap`を使用します。  
GitHubリポジトリをHomebrewに登録する仕組みとなっています。  

### `brew`

Homebrewに正式に登録されたライブラリをインストールする際には`brew`構文を作成します。  

### `cask`

Macアプリをインストールする際には`cask`構文を使います。  

### `mas`

`mas`構文を使用するとApp StoreからMacアプリをインストールできます。  

### シンボリックリンクやPATHも自動化

先ほど説明したシンボリックリンク作成コマンドや最低限必要なPATHを通すためのコマンドもシェルスクリプトで用意しておくと楽です。

```
ln -s ~/dotfiles/.zshrc ~zshrc
```

また、シェルスクリプトを作成する際には以下のような内容に気をつけます。

- 冪等性を保つ(すでにインストールされている場合はスキップしたりして何度実行しても同じ結果になるようにしておく)
- 実行する場所がどこでも正常に終了するようにパスを工夫しておく

### CIの作成

dotfilesにもCIの考えを導入することができます。  
GitHub Actions等を用いてインストールコマンドが成功するかどうかを確認できます。  
今回は作成していないんですがいずれ挑戦したいと思います。

参考: https://dev.classmethod.jp/articles/joined-mac-dotfiles-customize/


## 所感

新しいPCを買うのと合わせてセットアップの自動化スクリプトをいじった週末でした。  
エンジニアのこういう自動化文化自体が大好きなのでこれからもメンテナンスして自分なりのdotfilesを育てていきたいと思います!  
また、Docker等を使用する上でもLinux、というよりUnix系のコマンドを理解しておくと色々と捗りそうなのでそのあたりも学習していきたいと思います。

## おまけ

### シェルスクリプトにちょっと入門してみる

先ほど気をつけた方がいいと書いた

- 冪等性を保つ(すでにインストールされている場合はスキップしたりして何度実行しても同じ結果になるようにしておく)
- 実行する場所がどこでも正常に終了するようにパスを工夫しておく

について、シェルスクリプトでどう工夫するかについて調査してみます。

### 実行する場所の設定

スクリプトの配置位置や実行位置を気にせずにスクリプトを実行するには
```shell
SCRIPT_DIR=$(cd $(dirname $0); pwd)
```

- $0 で実行コマンドを取得
- dirname でベースディレクトリを取得
- サブシェル内で cd で移動
- pwd で絶対パスの取得

使用する際は`$SCRIPT_DIR`で使用できます。
シェルスクリプトの場合は「変数名=値」のように指定します。`=`の前後に空白を入れることができない点に注意が必要です。  
定義した変数の値は「$変数名」で参照できます。  

参考: https://qiita.com/koara-local/items/2d67c0964188bba39e29

### 冪等性を保つには

インストール済みの場合はコマンドを実行しないように工夫してみます。  

```shell
if ! type コマンド >/dev/null 2>&1; then
 # インストール処理
fi
```

基本的には上記で書けるのですが、内容についても調査してみます。

`type`コマンドを使用します。`type`コマンドはコマンドのタイプに関する情報を表示するコマンドです。  


- ファイルディスクリプタ

Unixには下記のように入出力に番号が振られています。  

- 0: 標準入力
- 1: 標準出力
- 2: 標準エラー出力

これら入出力をOSが判別するために割り当てられた番号を`ファイルディスクリプタ`といいます。

- リダイレクト

標準出力に出力した結果を別の場所に出力する際に`>`を使用できます。

- `/dev/null`とは

`/dev/null`はUnixのスペシャルファイルで、空ファイルを指します。

これを利用して、`type`コマンドの結果を捨てて分岐ロジックを書いていることが理解できました。


参考:  
https://qiita.com/yn-misaki/items/3ec0605cba228a7d5c9a  
https://qiita.com/ritukiii/items/b3d91e97b71ecd41d4ea  
https://qiita.com/i35_267/items/158cd20ed26f73a3d894  

